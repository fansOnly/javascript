<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>数据结构与算法之递归系列</title>
</head>
<body>
    <script>
        // https://mp.weixin.qq.com/s/xCT5esqM8Uv2jGmq88K0rg
        //※ 分类一：递归计算型 

        // 1、层层计算
        // 层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。

        // 问题一：有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。
        const fnAge = (index) => {
            return 10 + (index - 1) * 2;
        }
        // f(n) = f(n-1) + 2;
        // for (let i = 1; i <= 10; i ++) {
        //     console.log(`第${i}个人`, fnAge(i));
        // }

        // 问题二：单链表从尾到头一次输出结点值，用递归实现。????


        // 2、并列计算
        // 并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。

        // 斐波那契数列 0、1、1、2、3、5、8、13、21、34...
        // f(n) = f(n-1) + f(n-2)
        const Fibonacci = n => {
            if (n == 0) return 0;
            if (n == 1) return 1;
            return Fibonacci(n-1) + Fibonacci(n-2);
        }
        console.time('斐波那契数列');
        console.log(Fibonacci(10))
        console.timeEnd('斐波那契数列');

        // 举一反三：一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。
        // Fibonacci()
        // 进阶问题：一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级，...也可以跳上n 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。
        // 1阶：f(1) = 1
        // 2阶：f(2) = f(2-1) + f(1-1) = 2
        // 3阶：f(3) = f(3-1) + f(2-1) + f(1-1)
        // ...
        // n-1阶：f(n-1) = f(n-2) + f(n-1) + ... + f(n-n) = f(0) + f(1) + ... + f(n-2)
        // n阶：f(n) = f(n-1) + f(n-2) + ... + f(n-n) = f(0) + f(1) + ... + f(n-1)
        // fn = 2 * f(n-1)


        // ※ 分类二：递归枚举型
        // 递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。
        // 八皇后问题？？？？？


        // ※ 分类三：递归选择型
        // 所谓的递归选择型，每个子问题都要面临选择，求最优解的情况

        // 0 -1 背包问题(回溯算法)
        // 有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？






        // 递归的缺点
        // 1、递归堆栈溢出
        // 函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。
        // 2、递归重复元素
        // 一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）
        // 斐波那契数列改进版
        let map = new Map();
        const Fibonacci2 = n => {
            if (n == 0) return 0;
            if (n == 1) return 1;

            if (map.has(n)) {
                return map.get(n)
            }
            let num = Fibonacci2(n-1) + Fibonacci2(n -2)
            map.set(n, num)
            return num;
        }
        console.time('斐波那契数列改进版');
        console.log(Fibonacci2(10));
        console.timeEnd('斐波那契数列改进版');

        // 3、递归高空间复杂度
        // 因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。
    </script>
</body>
</html>